<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fractal Simulation — Mandelbrot & Julia</title>
  <style>
    :root{
      --bg:#0b1220;--panel:#0f1724;--muted:#97a0b3;--accent:#6ee7b7;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%, #071726 100%);font-family:Inter,system-ui,Segoe UI,Arial;color:#e6eef6}
    .app{display:grid;grid-template-columns:1fr 320px;gap:18px;height:100vh;padding:18px;box-sizing:border-box}
    .canvas-wrap{position:relative;border-radius:12px;overflow:hidden;box-shadow:0 10px 30px rgba(2,6,23,0.7)}
    canvas{width:100%;height:100%;display:block;background:linear-gradient(180deg, rgba(0,0,0,0.12), transparent)}
    .controls{background:var(--panel);border-radius:12px;padding:16px;display:flex;flex-direction:column;gap:12px;min-height:0}
    h1{margin:0;font-size:16px}
    label{font-size:13px;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    input[type=range]{width:100%}
    select,input[type=number]{width:100%;padding:8px;border-radius:8px;border:0;background:var(--glass);color:inherit}
    button{padding:8px 10px;border-radius:8px;border:0;background:linear-gradient(90deg,var(--accent),#4fd1c5);color:#052018;cursor:pointer}
    .small{font-size:12px;color:var(--muted)}
    .footer{margin-top:auto;font-size:12px;color:var(--muted);display:flex;justify-content:space-between;align-items:center}
    .topbar{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.25);padding:8px;border-radius:10px;backdrop-filter:blur(6px)}
    .info{font-size:13px}
    @media(max-width:880px){.app{grid-template-columns:1fr;grid-template-rows:auto 320px}.controls{order:2}}
  </style>
</head>
<body>
  <div class="app">
    <div class="canvas-wrap">
      <div class="topbar">
        <div class="info"><strong id="title">Mandelbrot set</strong> — left-drag to zoom · wheel to zoom · right-drag to pan</div>
      </div>
      <canvas id="fractal"></canvas>
    </div><aside class="controls">
  <div>
    <h1>Fractal Simulation</h1>
    <div class="small">Interactive Mandelbrot / Julia renderer — progressive rendering for responsiveness.</div>
  </div>

  <div>
    <label>Fractal type</label>
    <select id="type">
      <option value="mandelbrot">Mandelbrot</option>
      <option value="julia">Julia (click canvas to set c)</option>
    </select>
  </div>

  <div>
    <label>Max iterations: <span id="iterLabel">300</span></label>
    <input id="maxIter" type="range" min="50" max="2000" step="10" value="300">
  </div>

  <div>
    <label>Color scheme</label>
    <select id="palette">
      <option value="smooth">Smooth</option>
      <option value="rgb">RGB bands</option>
      <option value="fire">Fire</option>
      <option value="ice">Ice</option>
    </select>
  </div>

  <div>
    <label>Render quality (pixels per step)</label>
    <select id="quality">
      <option value="1">High (1 px)</option>
      <option value="2">Medium (2 px)</option>
      <option value="4">Low (4 px)</option>
    </select>
  </div>

  <div class="row">
    <button id="reset">Reset view</button>
    <button id="save">Save image</button>
  </div>

  <div class="row">
    <label style="flex:1">Auto-animate Julia</label>
    <input type="checkbox" id="animateJulia">
  </div>

  <div class="footer">
    <div>FPS: <span id="fps">—</span></div>
    <div class="small">by FractalSim</div>
  </div>
</aside>

  </div><script>
(() => {
  const canvas = document.getElementById('fractal');
  const ctx = canvas.getContext('2d');
  let DPR = Math.min(window.devicePixelRatio || 1, 2);

  function resize(){
    canvas.width = canvas.clientWidth * DPR;
    canvas.height = canvas.clientHeight * DPR;
    scheduleRender(true);
  }
  window.addEventListener('resize', resize);

  // Controls
  const typeSel = document.getElementById('type');
  const maxIterEl = document.getElementById('maxIter');
  const iterLabel = document.getElementById('iterLabel');
  const paletteSel = document.getElementById('palette');
  const qualitySel = document.getElementById('quality');
  const resetBtn = document.getElementById('reset');
  const saveBtn = document.getElementById('save');
  const fpsEl = document.getElementById('fps');
  const animateJuliaEl = document.getElementById('animateJulia');

  let view = {x:-0.6, y:0, scale:3.0}; // center x,y and scale = width of view
  const defaultView = {...view};
  let maxIter = +maxIterEl.value;
  iterLabel.textContent = maxIter;
  let palette = paletteSel.value;
  let quality = +qualitySel.value;

  // Julia param
  let juliaC = {x:-0.8, y:0.156};
  let animTheta = 0;

  // Rendering state
  let frameRequested = false;
  let lastRenderTime = 0;

  function worldToPixel(wx, wy){
    const w = canvas.width; const h = canvas.height;
    const aspect = w/h;
    const scaleX = view.scale * aspect;
    const left = view.x - scaleX/2;
    const top = view.y - view.scale/2;
    const px = Math.floor(((wx - left)/scaleX) * w);
    const py = Math.floor(((wy - top)/view.scale) * h);
    return [px, py];
  }

  function pixelToWorld(px, py){
    const w = canvas.width; const h = canvas.height;
    const aspect = w/h; const scaleX = view.scale * aspect;
    const left = view.x - scaleX/2;
    const top = view.y - view.scale/2;
    const wx = left + (px / w) * scaleX;
    const wy = top + (py / h) * view.scale;
    return [wx, wy];
  }

  // Color palettes
  function paletteColor(i, znorm){
    // i = smoothed iteration value (float), znorm optional
    switch(palette){
      case 'rgb': {
        const v = Math.floor(i*10) % 256;
        return [v, (v*2)%256, (v*5)%256];
      }
      case 'fire': {
        const t = Math.min(1, i/Math.log(maxIter+1));
        return [Math.floor(255*Math.pow(t,0.6)), Math.floor(120*t), Math.floor(30*t)];
      }
      case 'ice': {
        const t = Math.min(1, i/Math.log(maxIter+1));
        return [Math.floor(20*t), Math.floor(200*t), Math.floor(255*Math.sqrt(t))];
      }
      default: {
        // smooth hue
        const hue = (360 * i / Math.log(maxIter+1)) % 360;
        return hsvToRgb(hue, 0.8, 1.0);
      }
    }
  }
  function hsvToRgb(h, s, v){
    const c = v*s; const x = c*(1 - Math.abs((h/60)%2 -1)); const m = v-c;
    let r=0,g=0,b=0;
    if(h<60){r=c;g=x;b=0;}else if(h<120){r=x;g=c;b=0;}else if(h<180){r=0;g=c;b=x;}else if(h<240){r=0;g=x;b=c;}else if(h<300){r=x;g=0;b=c;}else{r=c;g=0;b=x;}
    return [Math.floor((r+m)*255),Math.floor((g+m)*255),Math.floor((b+m)*255)];
  }

  // Escape-time (returns smoothed iteration or maxIter)
  function escapeTime(cx, cy, isJulia=false){
    let x = isJulia? cx : 0.0;
    let y = isJulia? cy : 0.0;
    const cx0 = isJulia? juliaC.x : cx;
    const cy0 = isJulia? juliaC.y : cy;
    let iter = 0;
    let xx=0, yy=0, xy=0;
    while(iter < maxIter){
      xx = x*x; yy = y*y;
      if(xx + yy > 4.0) break;
      xy = 2*x*y;
      x = xx - yy + cx0;
      y = xy + cy0;
      iter++;
    }
    if(iter === maxIter) return maxIter;
    // smooth coloring
    const mag = Math.sqrt(xx+yy);
    const mu = iter + 1 - Math.log(Math.log(mag))/Math.log(2);
    return mu;
  }

  // Progressive rendering in tiles to keep UI responsive
  function renderStep(chunkSize=64){
    const w = canvas.width, h = canvas.height;
    const img = ctx.getImageData(0,0,w,h);
    const data = img.data;
    const aspect = w/h; const scaleX = view.scale * aspect;
    const left = view.x - scaleX/2;
    const top = view.y - view.scale/2;

    const step = quality;
    let px = 0, py = 0;
    let start = performance.now();
    // iterate over pixels in a cooperative manner
    for(py = 0; py < h; py += step){
      for(px = 0; px < w; px += step){
        // check if we should yield
        const idx = (py*w + px)*4;
        const wx = left + (px / w) * scaleX;
        const wy = top + (py / h) * view.scale;
        const mu = escapeTime(wx, wy, typeSel.value === 'julia');
        if(mu >= maxIter){
          data[idx] = data[idx+1] = data[idx+2] = 0; data[idx+3]=255;
        } else {
          const col = paletteColor(mu);
          data[idx]=col[0]; data[idx+1]=col[1]; data[idx+2]=col[2]; data[idx+3]=255;
        }
        // fill block for quality>1
        if(step>1){
          for(let dy=0; dy<step; dy++){
            for(let dx=0; dx<step; dx++){
              const x2 = Math.min(w-1, px+dx);
              const y2 = Math.min(h-1, py+dy);
              const id2 = (y2*w + x2)*4;
              data[id2]=data[idx];data[id2+1]=data[idx+1];data[id2+2]=data[idx+2];data[id2+3]=255;
            }
          }
        }
      }
      // yield every few rows
      if(performance.now() - start > 20){
        ctx.putImageData(img,0,0);
        // schedule next slice
        setTimeout(() => renderStep(chunkSize), 1);
        return;
      }
    }
    ctx.putImageData(img,0,0);
    frameRequested = false;
  }

  function scheduleRender(force=false){
    if(force){ frameRequested = false; }
    if(frameRequested) return;
    frameRequested = true;
    requestAnimationFrame(() => {
      renderStep();
      lastRenderTime = performance.now();
      frameRequested = false;
    });
  }

  // UI listeners
  maxIterEl.addEventListener('input', e => { maxIter = +e.target.value; iterLabel.textContent = maxIter; scheduleRender(true); });
  paletteSel.addEventListener('change', e => { palette = e.target.value; scheduleRender(true); });
  qualitySel.addEventListener('change', e => { quality = +e.target.value; scheduleRender(true); });
  typeSel.addEventListener('change', e => { document.getElementById('title').textContent = e.target.value === 'mandelbrot' ? 'Mandelbrot set' : 'Julia set'; scheduleRender(true); });
  resetBtn.addEventListener('click', ()=>{ view = {...defaultView}; scheduleRender(true); });
  saveBtn.addEventListener('click', ()=>{ const url = canvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='fractal.png'; a.click(); });

  // Mouse interactions: left-drag select zoom box; right-drag pan; wheel zoom; click to set Julia c
  let isLeftDown=false, isRightDown=false, dragStart=null;
  canvas.addEventListener('pointerdown', (e)=>{
    canvas.setPointerCapture(e.pointerId);
    if(e.button === 0){ isLeftDown = true; dragStart = {x:e.clientX, y:e.clientY}; }
    if(e.button === 2){ isRightDown = true; dragStart = {x:e.clientX, y:e.clientY}; }
  });
  canvas.addEventListener('pointermove', (e)=>{
    if(isRightDown && dragStart){
      // pan
      const dx = (e.clientX - dragStart.x)/canvas.clientWidth * view.scale * (canvas.width/canvas.clientWidth) ;
      const dy = (e.clientY - dragStart.y)/canvas.clientHeight * view.scale ;
      const aspect = canvas.width / canvas.height;
      view.x -= dx; view.y -= dy;
      dragStart = {x:e.clientX, y:e.clientY};
      scheduleRender();
    }
  });
  canvas.addEventListener('pointerup', (e)=>{
    canvas.releasePointerCapture(e.pointerId);
    if(e.button === 0 && isLeftDown && dragStart){
      // compute zoom to selection
      const rect = canvas.getBoundingClientRect();
      const sx = dragStart.x - rect.left; const sy = dragStart.y - rect.top;
      const ex = e.clientX - rect.left; const ey = e.clientY - rect.top;
      if(Math.hypot(ex-sx, ey-sy) < 8){
        // small click => if julia mode, set c
        if(typeSel.value === 'julia'){
          const [wx,wy] = pixelToWorld(Math.floor(sx*DPR), Math.floor(sy*DPR));
          juliaC.x = wx; juliaC.y = wy; scheduleRender(true);
        }
      } else {
        // zoom into box
        const x1 = Math.min(sx, ex), x2 = Math.max(sx, ex);
        const y1 = Math.min(sy, ey), y2 = Math.max(sy, ey);
        const [w1,h1] = [x1*DPR, y1*DPR];
        const [w2,h2] = [x2*DPR, y2*DPR];
        const [wx1,wy1] = pixelToWorld(w1, h1);
        const [wx2,wy2] = pixelToWorld(w2, h2);
        view.x = (wx1 + wx2)/2;
        view.y = (wy1 + wy2)/2;
        view.scale = Math.abs(wx2 - wx1);
        scheduleRender(true);
      }
    }
    if(e.button === 2 && isRightDown){ isRightDown=false; }
    isLeftDown=false; dragStart=null;
  });
  // prevent context menu on canvas
  canvas.addEventListener('contextmenu', e => e.preventDefault());

  canvas.addEventListener('wheel', e =>{
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * DPR; const my = (e.clientY - rect.top) * DPR;
    const [wx,wy] = pixelToWorld(mx,my);
    const zoom = Math.exp(e.deltaY * -0.0015);
    view.scale *= zoom;
    // keep point under cursor fixed
    view.x = wx + (view.x - wx) * zoom;
    view.y = wy + (view.y - wy) * zoom;
    scheduleRender(true);
  }, {passive:false});

  // Animation loop for Julia param
  function animate(){
    if(animateJuliaEl.checked && typeSel.value === 'julia'){
      animTheta += 0.01;
      juliaC.x = -0.7885 * Math.cos(animTheta);
      juliaC.y = 0.156 * Math.sin(animTheta);
      scheduleRender();
    }
    // crude fps
    requestAnimationFrame(()=>{
      fpsEl.textContent = Math.round(1000/(performance.now()-lastRenderTime || 16));
      animate();
    });
  }
  animate();

  // initialize
  resize();
  scheduleRender(true);

})();
</script></body>
</html>